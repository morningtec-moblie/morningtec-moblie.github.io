<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FindBugs代码检查工具]]></title>
    <url>%2F2017%2F10%2F24%2FFindBugs%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[在项目中集成FindBugs能检查出代码中的潜在Bugs，自动地静态代码分析，极大地保证了项目的代码质量，下面就简单介绍一下，FindBugs的接入和配置。 下载插件打开android studio的settingds-&gt;Plugins-&gt;Browse Repositories搜索findbugs，选择FindBugs，点击右边的Install，下载好之后重启android studio。 简单集成在build.gradle文件中写入： 123456789101112131415161718192021222324apply plugin: 'findbugs'......task findbugs(type: FindBugs, dependsOn: "assembleDebug") &#123; ignoreFailures = false effort = "max" reportLevel = "high" classes = files("$&#123;project.rootDir&#125;/app/build/intermediates/classes") source = fileTree("src/main/java/") reports &#123; xml.enabled = false html.enabled = true xml &#123; destination "$reportsDir/findbugs/findbugs.xml" //这里是报告产生的路径 &#125; html &#123; destination "$reportsDir/findbugs/findbugs.html" //这里是报告产生的路径 &#125; &#125; classpath = files()&#125; FindBugs按钮说明 当前文件检查； 当前包路径下代码检查； 当前模块检查； 当前项目检查； 自定义文件检查 检查结果按Bug分类 检查结果按文件分类 检查结果按包路径分类 检查结果按Bug级别分类 FindBugs配置 把检查结果导出 导入检查结果 设置过滤文件点击上图的12按钮 点击Filter-&gt;Exclude filter files下的+号选中自定义的过滤文件，然后点击Apply。 findbugs-filter.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;FindBugsFilter&gt; &lt;!-- http://stackoverflow.com/questions/7568579/eclipsefindbugs-exclude-filter-files-doesnt-work --&gt; &lt;Match&gt; &lt;Class name="~.*\.R\$.*"/&gt; // 过滤R文件 &lt;/Match&gt; &lt;Match&gt; &lt;Class name="~.*\.Manifest\$.*"/&gt; // 过滤Mainifest文件 &lt;/Match&gt; &lt;!-- All bugs in test classes, except for JUnit-specific bugs --&gt; &lt;Match&gt; &lt;Class name="~.*\.*Test" /&gt; &lt;Not&gt; &lt;Bug code="IJU" /&gt; &lt;/Not&gt; &lt;/Match&gt;&lt;/FindBugsFilter&gt;]]></content>
      <categories>
        <category>代码检查工具</category>
        <category>by曾浩</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDFA、IDFV、UUID的变化测试，以及设备唯一标识获取]]></title>
    <url>%2F2017%2F10%2F18%2FIDFA%E3%80%81IDFV%E3%80%81UUID%E7%9A%84%E5%8F%98%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[获取UUID123456789101112131415161718192021+ (NSString *)createUUID&#123; // Create universally unique identifier (object) CFUUIDRef uuidObject = CFUUIDCreate(kCFAllocatorDefault); // Get the string representation of CFUUID object. NSString *uuidStr = (NSString *)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, uuidObject)); // If needed, here is how to get a representation in bytes, returned as a structure // typedef struct &#123; // UInt8 byte0; // UInt8 byte1; // ... // UInt8 byte15; // &#125; CFUUIDBytes; //CFUUIDBytes bytes = CFUUIDGetUUIDBytes(uuidObject); CFRelease(uuidObject); return uuidStr;&#125; IDFA12345+ (NSString *)getIDFAString&#123; NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; return adId;&#125; IDFV12345+ (NSString *)getIDFVString&#123; NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; return idfv;&#125; 测试iPhone 6s plus iOS9.0(模拟器)第一次1234idfa--------FA5A184C-933E-4E83-B5A2-55841F2011EDidfv--------74594A83-1E41-4531-9A80-48BA72FB562Fuuid--------E91AEF82-5E5C-40F8-90D6-63B9ACB66CF7keychains---E607AD64-4F21-4E0F-8D46-55E3CEDE91AA 第二次1234idfa--------FA5A184C-933E-4E83-B5A2-55841F2011EDidfv--------74594A83-1E41-4531-9A80-48BA72FB562Fuuid--------3AAC0C7F-5616-4063-A8AC-D65A5B9A1056keychains---E607AD64-4F21-4E0F-8D46-55E3CEDE91AA 卸载重装1234idfa--------FA5A184C-933E-4E83-B5A2-55841F2011EDidfv--------7AB3F4C8-3973-4DA1-93F0-DE88FD7F235Auuid--------24F753C2-0205-45CC-B416-BA679909C1E9keychains---E607AD64-4F21-4E0F-8D46-55E3CEDE91AA ipad,iOS 10.2.1 （真机）第一次1234idfa--------FBF3BF74-1C10-4AC9-9AD8-F9D0FF0753CFidfv--------64B1DFCF-951D-49F4-B4F4-CC5095316B5Cuuid--------F609B6A4-C1D1-4301-89E6-0E16B94EF170keychains---1E0D87A5-0A1F-484E-9C98-8920B2E16F27 第二次1234idfa--------FBF3BF74-1C10-4AC9-9AD8-F9D0FF0753CFidfv--------64B1DFCF-951D-49F4-B4F4-CC5095316B5Cuuid--------BBAC0119-C11A-4C45-AA9F-799570DD028Akeychains---1E0D87A5-0A1F-484E-9C98-8920B2E16F27 卸载重装：1234idfa--------FBF3BF74-1C10-4AC9-9AD8-F9D0FF0753CFidfv--------64B1DFCF-951D-49F4-B4F4-CC5095316B5Cuuid--------E73401B0-CA3D-4969-96A0-9C435ED2BED5keychains---1E0D87A5-0A1F-484E-9C98-8920B2E16F27 iPhone 8 plus, iOS 11 (模拟器)第一次1234idfa--------0BA97921-8F58-41C9-BFD0-E920BD9F8B59idfv--------7F7EE423-0BB3-4ABD-8304-F051B3B387BAuuid--------D12DE2E5-3A54-4AF2-A809-77C46E73169Ekeychains---ECD6366D-09F5-4349-A781-D67F4F3B6F35 第二次1234idfa--------0BA97921-8F58-41C9-BFD0-E920BD9F8B59idfv--------7F7EE423-0BB3-4ABD-8304-F051B3B387BAuuid--------D3A6EC1F-D46B-4A37-AECB-6B59A6BA1B1Dkeychains---ECD6366D-09F5-4349-A781-D67F4F3B6F35 卸载重装：1234idfa--------0BA97921-8F58-41C9-BFD0-E920BD9F8B59idfv--------DC04933D-65C1-4020-8583-18040F338F6Fuuid--------133D20C7-ED69-4ED9-BCBC-D0B38EF214DDkeychains---ECD6366D-09F5-4349-A781-D67F4F3B6F35 iPad iOS11.0.3 （真机）第一次1234idfa--------DB08FC60-1CE6-4EC5-A20A-D8B909F62642idfv--------B5F266E9-2BCA-46A2-B304-A2BB6C57EF55uuid--------65C3AD4A-F9D5-40D4-BCE4-4E6184D68BC4keychains---644B1FE5-A454-4ACE-AB82-E5B5C1F9127D 第二次1234idfa--------DB08FC60-1CE6-4EC5-A20A-D8B909F62642idfv--------B5F266E9-2BCA-46A2-B304-A2BB6C57EF55uuid--------5149E9A5-1D65-4989-A6E8-149479F4225Dkeychains---644B1FE5-A454-4ACE-AB82-E5B5C1F9127D 卸载重装1234idfa--------DB08FC60-1CE6-4EC5-A20A-D8B909F62642idfv--------FF76D818-6839-40EC-9C88-58D1CE2A8DC1uuid--------8D892E51-07A1-4F8A-9076-C01A21B1800Bkeychains---644B1FE5-A454-4ACE-AB82-E5B5C1F9127D 测试结果：1，iOS10.2.1 系统下idfa、idfv、keychains在杀进程运行和卸载重装均不会改变； 2，iOS9.0 、iOS11.0 系统下idfa、keychains在杀进程运行和卸载重装均不会改变, idfv 卸载重装会改变； 结论：为了获取设备唯一ID 方案1:可以先获取idfa，如果获取不到，就获取idfv。第一次获取到的值保存到钥匙串(keychains) 上代码12345678910111213141516// 获取唯一标识+(NSString *)getDeviceId&#123; NSString * deviceId = [SFHFKeychainMTSDKTool getPasswordForUsername:DEVICEID andServiceName:DEVICEID error:nil]; if(!deviceId)&#123; deviceId = [MTSDKTool getIDFAString]; if (!deviceId) &#123; deviceId = [MTSDKTool getIDFVString]; &#125; if([SFHFKeychainMTSDKTool storeUsername:DEVICEID andPassword:deviceId forServiceName:DEVICEID updateExisting:YES error:nil])&#123; return deviceId; &#125; else &#123; return nil; &#125; &#125; return deviceId;&#125; 方案2: 获取uuid，第一次获取到的值保存到钥匙串(keychains) 123456789101112+(NSString *)getDeviceId&#123; NSString * deviceId = [SFHFKeychainMTSDKTool getPasswordForUsername:DEVICEID andServiceName:DEVICEID error:nil]; if(!deviceId)&#123; deviceId = [MTSDKTool createUUID]; if([SFHFKeychainMTSDKTool storeUsername:DEVICEID andPassword:deviceId forServiceName:DEVICEID updateExisting:YES error:nil])&#123; return deviceId; &#125; else &#123; return nil; &#125; &#125; return deviceId;&#125; 定义 (延伸)UDID (Unique Device Identifier)苹果IOS设备的唯一识别码，它由40个字符的字母和数字组成。在很多需要限制一台设备一个账号的应用中经常会用到。在iOS5中可以获取到设备的UDID。 ⚠️后来被苹果禁止了。 UUID（Universally Unique Identifier）中文意思是通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。 开发者可以在应用第一次启动时调用一 次，然后将该串存储起来，替代UDID来使用。 但是，如果用户删除该应用再次安装时，又会生成新的字符串，所以不能保证唯一识别该设备。使用UUID，就要考虑应用被删除后再重新安装时的处理。 一个解决的办法是：UUID一般只生成一次，保存在iOS系统里面，如果应用删除了，重装应用之后它的UUID还是一样的，除非系统重置 。但是不能保证在以后的系统升级后还能用（如果系统保存了该信息就能用）。 MAC Address用来表示互联网上每一个站点的标识符，采用十六进制数表示，共六个字节（48位）。其中，前三个字节是由IEEE的注册管理机构 RA负责给不同厂家分配的代码(高位24位)，也称为“编制上唯一的标识符” （Organizationally Unique Identifier)，后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符（唯一性）。 MAC地址在网络上用来区分设备的唯一性，接入网络的设备都有一个MAC地址，他们肯定都是不同的，是唯一的。一部iPhone上可能有多个MAC地址，包括WIFI的、SIM的等，但是iTouch和iPad上就有一个WIFI的，因此只需获取WIFI的MAC地址就好了，也就是en0的地址。 MAC地址就如同我们身份证上的身份证号码，具有全球唯一性。这样就可以非常好的标识设备唯一性，类似与苹果设备的UDID号，通常的用途有：1）用于一些统计与分析目的，利用用户的操作习惯和数据更好的规划产品；2）作为用户ID来唯一识别用户，可以用游客身份使用app又能在服务器端保存相应的信息，省去用户名、密码等注册过程。 使用Mac地址生成设备的唯一标识主要分三种： 1、直接使用“MAC Address” 2、使用“MD5(MAC Address)” 3、使用“MD5(Mac Address+bundle_id)”获得“机器＋应用”的唯一标识（bundle_id 是应用的唯一标识） 在iOS7之后，如果请求Mac地址都会返回一个固定值。 IDFA（identifierForIdentifier）广告标示符，适用于对外：例如广告推广，换量等跨应用的用户追踪等。 是iOS 6中另外一个新的方法，提供了一个方法advertisingIdentifier，通过调用该方法会返回一个NSUUID实例，最后可以获得一个UUID，由系统存储着的。不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广 告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。 在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。 注意⚠️：由于idfa会出现取不到的情况，故绝不可以作为业务分析的主id，来识别用户。 IDFV（identifierForVendor）Vindor标示符，适用于对内：例如分析用户在应用内的行为等。 是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的DNS反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.somecompany.appone,com.somecompany.apptwo 这两个BundleID来说，就属于同一个Vender，共享同一个idfv的值。和idfa不同的是，idfv的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。 注意⚠️：如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。 参考：iOS获取设备唯一标识的各种方法？IDFA、IDFV、UDID分别是什么含义？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>设备唯一标识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码规范]]></title>
    <url>%2F2017%2F10%2F17%2FiOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[语言应该使用US英语. 应该:1UIColor *myColor = [UIColor whiteColor]; 不应该：1UIColor *myColour = [UIColor whiteColor]; 代码组织在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构： 12345678910111213141516171819202122232425262728293031323334353637#pragma mark - Lifecycle- (instancetype)init &#123;&#125;- (void)dealloc &#123;&#125;- (void)viewDidLoad &#123;&#125;- (void)viewWillAppear:(BOOL)animated &#123;&#125;- (void)didReceiveMemoryWarning &#123;&#125;#pragma mark - Custom Accessors- (void)setCustomProperty:(id)value &#123;&#125;- (id)customProperty &#123;&#125;#pragma mark - IBActions- (IBAction)submitData:(id)sender &#123;&#125;#pragma mark - Public- (void)publicMethod &#123;&#125;#pragma mark - Private- (void)privateMethod &#123;&#125;#pragma mark - Protocol conformance#pragma mark - UITextFieldDelegate#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - NSCopying- (id)copyWithZone:(NSZone *)zone &#123;&#125;#pragma mark - NSObject- (NSString *)description &#123;&#125; 空格缩进使用4个空格，确保在Xcode偏好设置来设置。(raywenderlich.com使用2个空格)方法大括号和其他大括号(if/else/switch/while 等.)总是在同一行语句打开但在新行中关闭。 应该: 12345if (user.isHappy) &#123; //Do something&#125; else &#123; //Do something else&#125; 不应该： 1234567if (user.isHappy)&#123; //Do something&#125;else &#123; //Do something else&#125; 在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。 优先使用auto-synthesis。但如果有必要，@synthesize 和 @dynamic应该在实现中每个都声明新的一行。 应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。 应该: 123456// blocks are easily readable[UIView animateWithDuration:1.0 animations:^&#123; // something&#125; completion:^(BOOL finished) &#123; // something&#125;]; 不应该： 12345678// colon-aligning makes the block indentation hard to read[UIView animateWithDuration:1.0 animations:^&#123; // something &#125; completion:^(BOOL finished) &#123; // something &#125;]; 推荐使用容器符号（[]以及{}）来表示数组和字典。容器符号与内容之间应使用空格分开 12NSArray* array = @[ [foo description], @&quot;Another String&quot;, [bar description] ];NSDictionary* dict = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;; 注释 语句注释 当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。任何被使用的注释都必须保持最新或被删除。一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。例外：这不应用在生成文档的注释 声明注释每个类、category和protocol都需在注释中说明它的用途以及在整个框架中的作用 变量注释尽可能详细地对关键变量进行注释，说明其作用 命名 Apple命名规则尽可能坚持，特别是与这些相关的memory management rules (NARC)。长的，描述性的方法和变量命名是好的。 应该: 1UIButton *settingsButton; 不应该： 1UIButton *setBut; 三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。 应该: 1static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3; 不应该： 1static NSTimeInterval const fadetime = 1.7; 属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@ synthesize语句，除非你有一个好的理由。 应该: 1@property (strong, nonatomic) NSString *descriptiveVariableName; 不应该： 1id varnm; 总体命名规范（遵循苹果官方规范）小驼峰命名法(CamelCase):第一个单词小写字母开头，其他单词首字母大写； 大驼峰命名法(PascalCase):所有首字母大写。 12345678910111213141516171819202122232425262728293031323334353637381、类名、协议名：遵循大驼峰命名法；2、常量：这里的常量指的是宏(#define)、枚举(enum)、常量(const)等，名称遵循大驼峰命名法；3、方法方法名和方法参数遵循相同的规则，使用小写开头的小驼峰法；避免使用下划线作为前缀，苹果公司保留这种使用，由第三方使用可能会导致命名冲突;4、变量：类成员变量，属性，局部变量，使用小写开头的小驼峰法，其中类成员变量在名称最前面加一个下划线，比如:myLovalVariable, _myInstanceVariable；变量名的名称尽量可以推测其用途，具有描述性。5、方法的参数命名：不要再方法名中使用类似 pointer,ptr这样的字眼去表示指针，参数本身的类型足以说明；不要使用简写，拼出完整的单词；6、前缀前缀是编程接口命名的重要部分，它们区分了软件的不同功能区域：前缀可以防止第三方开发者与Apple的命名冲突；同样可以防止Apple内部的命名冲突；前缀有指定格式：它由二到三个大写字母组成，不使用下划线和子前缀，命名类、协议、常量和typedef结构体时使用前缀。方法名不使用前缀（因为它存在于特定类的命名空间中），私有方法可以加前缀，比如private_XXX。结构体字段不使用前缀。 更多命名规则见 IOS 编码规范整理 下划线当使用属性时，实例变量应该使用self.来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有self.。 但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。 局部变量不应该包含下划线。 方法在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。 “and”这个词的用法应该保留。它不应该用于多个参数来说明，就像initWithWidth:height以下这个例子： 应该: 1234- (void)setExampleText:(NSString *)text image:(UIImage *)image;- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;- (id)viewWithTag:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不应该： 12345-(void)setT:(NSString *)text i:(UIImage *)image;- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;- (id)taggedView:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height; // Never do this. 变量变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在for()循环。 星号表示变量是指针。例如， NSString *text 既不是 NSString* text 也不是 NSString * text，除了一些特殊情况下常量。 私有变量 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。 通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(init, initWithCoder:, 等…)，dealloc 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看这里 应该: 12345@interface RWTTutorial : NSObject@property (strong, nonatomic) NSString *tutorialName;@end 不应该： 123@interface RWTTutorial : NSObject &#123; NSString *tutorialName;&#125; 属性特性所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。 应该: 12@property (weak, nonatomic) IBOutlet UIView *containerView;@property (strong, nonatomic) NSString *tutorialName; 不应该： 12@property (nonatomic, weak) IBOutlet UIView *containerView;@property (nonatomic) NSString *tutorialName; NSString应该使用copy 而不是 strong的属性特性。 为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。 应该: 1@property (copy, nonatomic) NSString *tutorialName; 不应该： 1@property (strong, nonatomic) NSString *tutorialName; 点符号语法点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读这里 点语法应该总是被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。 应该: 123NSInteger arrayCount = self.array.count;view.backgroundColor = [UIColor orangeColor];[UIApplication sharedApplication].delegate; 不应该： 123NSInteger arrayCount = [self.array count];[view setBackgroundColor:[UIColor orangeColor]];[[UIApplication sharedApplication] delegate]; 字面值NSString, NSDictionary, NSArray, 和 NSNumber的字面值应该在创建这些类的不可变实例时被使用。请特别注意nil值不能传入NSArray和NSDictionary字面值，因为这样会导致crash。 应该: 1234NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];NSDictionary *productManagers = @&#123;@&quot;iPhone&quot;: @&quot;Kate&quot;, @&quot;iPad&quot;: @&quot;Kamal&quot;, @&quot;Mobile Web&quot;: @&quot;Bill&quot;&#125;;NSNumber *shouldUseLiterals = @YES;NSNumber *buildingStreetNumber = @10018; 不应该： 1234NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018]; 常量常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用static来声明而不是使用#define，除非显式地使用宏。 应该: 123static NSString * const RWTAboutViewControllerCompanyName = @&quot;RayWenderlich.com&quot;;static CGFloat const RWTImageThumbnailHeight = 50.0; 不应该： 12#define CompanyName @&quot;RayWenderlich.com&quot;#define thumbnailHeight 2 枚举类型当使用enum时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏NS_ENUM()来帮助和鼓励你使用固定的基本类型。 例如: 12345typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) &#123; RWTLeftMenuTopItemMain, RWTLeftMenuTopItemShows, RWTLeftMenuTopItemSchedule&#125;; 你也可以显式地赋值(展示旧的k-style常量定义)： 123456typedef NS_ENUM(NSInteger, RWTGlobalConstants) &#123; RWTPinSizeMin = 1, RWTPinSizeMax = 5, RWTPinCountMin = 100, RWTPinCountMax = 500,&#125;; 旧的k-style常量定义应该避免除非编写Core Foundation C的代码。 不应该： 1234enum GlobalConstants &#123; kMaxPinSize = 5, kMaxPinCount = 500,&#125;; Case语句大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。 12345678910111213141516switch (condition) &#123; case 1: // ... break; case 2: &#123; // ... // Multi-line example using braces break; &#125; case 3: // ... break; default: // ... break;&#125; 有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。 12345678910switch (condition) &#123; case 1: // ** fall-through! ** case 2: // code executed for values 1 and 2 break; default: // ... break;&#125; 当在switch使用枚举类型时，’default’是不需要的。例如： 12345678910111213RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;switch (menuType) &#123; case RWTLeftMenuTopItemMain: // ... break; case RWTLeftMenuTopItemShows: // ... break; case RWTLeftMenuTopItemSchedule: // ... break;&#125; 私有属性私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用+Private.h文件的命名规则暴露给测试。 例如: 1234567@interface RWTDetailViewController ()@property (strong, nonatomic) GADBannerView *googleAdView;@property (strong, nonatomic) ADBannerView *iAdView;@property (strong, nonatomic) UIWebView *adXWebView;@end 布尔值Objective-C使用YES和NO。因为true和false应该只在CoreFoundation，C或C++代码使用。既然nil解析成NO，所以没有必要在条件语句比较。不要拿某样东西直接与YES比较，因为YES被定义为1和一个BOOL能被设置为8位。 这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。 应该: 12if (someObject) &#123;&#125;if (![anotherObject boolValue]) &#123;&#125; 不应该： 12345678if (someObject == nil) &#123;&#125;if ([anotherObject boolValue] == NO) &#123;&#125;if (isAwesome == YES) &#123;&#125; // Never do this.if (isAwesome == true) &#123;&#125; // Never do this.如果BOOL属性的名字是一个形容词，属性就能忽略&quot;is&quot;前缀，但要指定get访问器的惯用名称。例如：@property (assign, getter=isEditable) BOOL editable;文字和例子从这里引用Cocoa Naming Guidelines 条件语句条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，even more dangerous defect可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。 应该: 123if (!error) &#123; return success;&#125; 不应该： 12if (!error) return success; 或 1if (!error) return success; 三元操作符当需要提高代码的清晰性和简洁性时，三元操作符?:才会使用。单个条件求值常常需要它。多个条件求值时，如果使用if语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。 Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。 应该: 12345NSInteger value = 5;result = (value != 0) ? x : y;BOOL isHorizontal = YES;result = isHorizontal ? x : y; 不应该： 1result = a &gt; b ? x = c &gt; d ? c : d : y; Init方法Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用instancetype而不是id 1234567- (instancetype)init &#123; self = [super init]; if (self) &#123; // ... &#125; return self;&#125; 查看关于instancetype的文章Class Constructor Methods 类构造方法当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。 123@interface Airplane+ (instancetype)airplaneWithType:(RWTAirplaneType)type;@end 关于更多instancetype信息，请查看NSHipster.com CGRect函数当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry: 在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。应该: 1234567CGRect frame = self.view.frame;CGFloat x = CGRectGetMinX(frame);CGFloat y = CGRectGetMinY(frame);CGFloat width = CGRectGetWidth(frame);CGFloat height = CGRectGetHeight(frame);CGRect frame = CGRectMake(0.0, 0.0, width, height); 不应该： 1234567CGRect frame = self.view.frame;CGFloat x = frame.origin.x;CGFloat y = frame.origin.y;CGFloat width = frame.size.width;CGFloat height = frame.size.height;CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; # 黄金路径当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。 应该: 1234567- (void)someMethod &#123; if (![someOther boolValue]) &#123; return; &#125; //Do something important&#125; 不应该： 12345- (void)someMethod &#123; if ([someOther boolValue]) &#123; //Do something important &#125;&#125; 错误处理当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。 应该: 1234NSError *error;if (![self trySomethingWithError:&amp;error]) &#123; // Handle Error&#125; 不应该： 12345NSError *error;[self trySomethingWithError:&amp;error];if (error) &#123; // Handle Error&#125; 在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。 单例模式单例对象应该使用线程安全模式来创建共享实例。 12345678910+ (instancetype)sharedInstance &#123; static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; 这会防止possible and sometimes prolific crashes. 换行符换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。 例如: 12345self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];一行很长的代码应该分成两行代码，下一行用两个空格隔开。self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; Xcode工程物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据类型来分组，而且还可以根据功能来分组，这样代码更加清晰。 尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下additional warnings。如果你需要忽略特殊的警告，使用 Clang’s pragma feature。 语法糖代码中使用语法糖，提高写代码效率 NSArray 1234//NSArray的定义 NSArray *array = @[@&quot;lu&quot;, @&quot;da&quot;, @&quot;shi&quot;, @YES, @123]; //NSArray的访问 array[index]; NSDictionary 12345678//NSDictionary的定义简化NSDictionary *dictionary = @&#123; @&quot;key0&quot; : @&quot;value0&quot;, @&quot;key1&quot; : @&quot;value1&quot;, @&quot;key2&quot; : @&quot;value2&quot; &#125;; //NSDictionary访问数据简化 dictionary[@&quot;key2&quot;]; NSNumber 123NSNumber *a = @123;NSNumber *b = @11.2;NSNumber *c = @(&apos;a&apos;); 项目工程目录当前SDK项目目录（面向对象） ApplicationLayer（应用层） Base（基类） View （UI类） DataAccessLayer（数据层） Network（网络层） Common（公共数据处理方法） Model（数据模型） DataSDKNeed（SDK需要数据收集） Persistence（数据缓存） ServiceLayer(服务层) Services（服务） Common（全局pch等头文件） Libs（第三方） Category (分类) Tools (工具类) Other (其他) Other(扩展) 其他案例： Modules：存放功能模块。将程序划分为多个功能模块，每个模块基于MVC/MVVM组织代码 Library：存放三方库 Util：存放自己封装的工具类 Catergory：存放扩展类 Custom：存放自定义的其他类 MacroAndConstant：存放宏定义和常量的文件 BaseViewController：基类，单独提出来 SupportingFile：存放项目配置文件 Resource：存放资源，按照图片，音频，视频不同分类存放 Request：封装的网络请求类 参考：Objective-C编码规范[译] IOS 编码规范整理 iOS团队代码规范（OC版）]]></content>
      <categories>
        <category>iOS</category>
        <category>by范献超</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>代码规范</tag>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码规范]]></title>
    <url>%2F2017%2F10%2F16%2FAndroid%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[一：文件命名规范：1、Class文件命名：① 类文件名采用驼峰命名法，以大写字母开头； ② 继承组件的类应该以组件名结尾，例如：XxxActivity，XxxService，XxxReceiver，XxxProvider， XxxFragment，XxxDialog… ② 自定义控件以继承的控件名结尾，例如：xxxImage， xxxButton， xxxView，xxxLayout… ③ 工具类以Utils结尾，例如：HttpUtils，ImageLoadUtils，SPUtils… 2、Resources 文件命名：① drawable文件命名： Asset Type 前缀 示例 Action bar ab_ ab_setting Button btn_ btn_home_normal，btn_home_pressed Divider divider_ divider_vertical Icon ic_ ic_start Menu menu_ menu_share Tabs tab_ tab_news background _bg login_bg ② 选择器状态的文件命名： State Suffix 尾缀 示例 Normal _normal ic_order_normal Pressed _pressed ic_order_pressed Focused _focused ic_order_focused Disabled _disabled ic_order_disabled Selected _selected ic_order_selected ③ layout文件命名：layout_main, fragment_home, item_photo，dialog_change_password，popup_date… ④ 控件id命名： 控件 缩写 示例 LinearLayout ll ll_friend RelativeLayout rl rl_message FrameLayout fl fl_cart TableLayout tab tl_news RecyclerView rv rv_list Button btn btn_publish ImageButton ibtn ibtn_avatar TextView tv tv_name ImageView iv iv_head EditText et et_password 代码内部命名：① 类变量命名： 公有变量按小驼峰命名； 静态常量以大写字母+下划线命名； 非公有&amp;非静态变量以m开头； 私有&amp;静态变量以s开头； 使用功能/描述+类型命名； 变量较多，分类摆放并注释； 接口类在最后； get，set方法去掉m 方法形参用_开头 方法名见名知意 尽量使用三目运算符 接口尽量不要使用内部类，多个接口方法加上开始-结束注释 if 判断加上 {} 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CodeStandard implements LoginType &#123; // 公有变量按小驼峰命名； public String userName = "zhangSan"; // 静态常量以大写字母+下划线命名； public final static LOGIN_TYPE = "weixnLogin"; // 非公有&amp;非静态变量以m开头； private String mPassword = "123456"; // 私有&amp;静态变量以s开头； private static String sAddress = "上海" private Login mLogin; public void init() &#123; mLogin.setLogin(this) &#125; // 方法形参用 _ 开头 public void setPassword(String _password) &#123; this.mPassword = _password; &#125; public String getPassword() &#123; this.mPassword; &#125; // 方法名见名知意，尽量使用三目运算符。 public int max(int _value1, int _value2)&#123; return _value1 &gt; _value ? _value1 : _value2 &#125; &lt;!-- 登录类型的接口方法 start--&gt; public void qqLogin() &#123; ... &#125; public void weixinLogin() &#123; ... &#125; &lt;!-- 登录类型的接口方法 end--&gt;&#125;]]></content>
      <categories>
        <category>代码规范</category>
        <category>by曾浩</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本号规则]]></title>
    <url>%2F2017%2F10%2F13%2F%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[版本号管理方案：一、版本号总体说明产品版本 2.0.0 别名：xxx （可理解为开发代号，可选） 1、第一位为大版本号，表示重大变动，比如添加论坛、重构这种行为 2、第二位为中间版本号，表示功能部分变动，比如修改ui，添加公开方法 3、第三位为修订号，表示修复bug后的稳定版本 关于版本号的自增规则每上一位的版本号增加时，后一位重置 例1：当前版本： 2.1.2 更新一个大版本，第一位加一，则得到： 3.0.0 例2：当前版本： 2.2.34 更新一个小版本，第二位加一，则得到： 2.3.0 二、版本号示例1、修订号 2.0.2 第二次修订,修复bug后的稳定版本 2.0.12 第十二次修订，修复bug后的稳定版本 – 2、构建号 2.0.2.156 第156次build (没有jinkens自动打包时可先命名为：2.0.2) – 3、代码版本-目前用不到 2.0.2-release、更多为开发阶段git代码管理 – 4、发布版本号 一般同修订号一致 2.0.2]]></content>
      <categories>
        <category>团队协作</category>
        <category>by杨佳欢</category>
      </categories>
      <tags>
        <tag>工作流程</tag>
        <tag>版本号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队Git协作方案]]></title>
    <url>%2F2017%2F10%2F13%2F%E5%9B%A2%E9%98%9FGit%E5%8D%8F%E4%BD%9C%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[团队Git协作方案git分支分类： 1、master 当前最新的稳定版本 2、developer 用于发布前多人协作时合并 一、master分支规则master分支主要分一下下两种 1、master 当前最新的稳定版本 2、master-项目名称-版本号-封包时间 例：master-gulugames-2.0.2-20171212 每一个稳定版本需要保存分支，保存的分支超过30个时，从最老的开始删除，保持最新的20个分支 二、developer分支规则developer分支主要分为以下两种 1、developer-项目名称-版本号-开始开发时间 当前版本的开发版分支，用于合并其他人的分支后出包,在正式上线之后，合并进对应的master分支 例：developer-gulugames-2.0.2-20171202 2、人员简拼-developer-项目名称-版本号 开发人员用于开发自己对应功能的分支，每个阶段开发完成后合并进1中的分支 例：yangjh-developer-gulugames-2.0.2 用于合并的开发分支以及个人分支在正式封包并上线之后删除 注：在个人developer分支合并进 二、git提交备注规范git提交一般分为三种状况 一、jira任务提交1、jira-jira任务编号(-进度) (这种主要是开发某个jira任务时提交，进度部分为可选) 例：jire-SDK-23-50%(当前任务没有完成时) jira-SDK-23(当前任务完成时) 二、bug修复1、bug(-bugfree编号/bug描述) (bugfree上的bug填bug编号，否则填bug描述) 例：bug-6187 bug-修复了登陆时不显示loading的问题 三、优化工作1、adv-(jira任务编号/优化描述) (有jira任务时用jira编号，没有时用描述) 例：adv-SDK-23 adv-优化浮窗流畅性 ​​ ## 一、git分支管理 一、版本号规则：产品版本 2.0.0 别名：xxx （可理解为开发代号，可选） 修订号 2.0.2 第二次修订,修复bug后的稳定版本 构建号 2.0.2.156 第156次build (没有jinkens自动打包时可先命名为：2.0.2) 代码版本 2.0.2-release、更多为开发阶段git代码管理 发布版本号 一般同修行号一致 2.0.2 ​]]></content>
      <categories>
        <category>团队协作</category>
        <category>by杨佳欢</category>
      </categories>
      <tags>
        <tag>工作流程</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和Github搭建技术博客]]></title>
    <url>%2F2017%2F09%2F28%2F%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言当前比较流行的方法就是Hexo与Github搭建博客。Hexo是一个快速、简洁且高效的博客框架，有比较丰富的主题和插件支持。Github为用户提供了Github Pages，其空间免费稳定，非常适合搭建个人博客。下面就为大家介绍如何使用Hexo和Github来搭建一个技术博客。 准备工作需要先安装以下两个软件： nodejs 我这里下载的是6.11.1版本 git 安装Hexo① 安装打开cmd.exe，输入以下命令，安装Hexo1npm install hexo-cli -g ② 初始化在你任意文件夹中创建一个用来存放博客的文件夹，我这里选的是 E:\MyBlog；在跟目录文件夹下输入以下命令进行初始化：1hexo init 然后输入1npm install 再输入：1hexo g 最后输入：1hexo s 此时博客就创建好了，你可以打开localhost:4000这个链接查看。介绍以下，hexo常用命令：hexo init //初始化一个文件夹，它会为这个文件夹配置所有骨架hexo g //即hexo generate，生成静态文件hexo s //即hexo server，创建服务hexo d //即hexo deploy,用于将本地文件发布到github上hexo n //即hexo new,用于新建一篇文章现在只是在本地搭建了一个技术博客，要想把博客内容让所有人都能看到，就得借助Github了，把博客内容部署到Github上去。 部署至Github① 在Github注册一个账号，并创建一个仓库。② 仓库名要设置和用户名相同，所以我这仓库名设置为morningtec-moblie.github.io③ 将Github账号密码设置到本地git中，你也可以配置SSH④ 将博客的根目录的_config.yml文件的底部deploy设置为：1234deploy: type: git repository: https://github.com/morningtec-moblie/morningtec-moblie.github.io.git branch: master 注意：冒号（:）后都有一个空格。你可以把此段代码复制过去，并把https://github.com/morningtec-moblie/morningtec-moblie.github.io.git替换为你自己的Github仓库路径⑤ 部署：在跟目录文件夹下输入hexo g，在输入hexo d，如果此时报错你可以输入npm install hexo-deployer-git --save来解决⑥ 如果上面都没什么问题的话，访问morningtec-moblie.github.io就能看到自己的博客了。 绑定域名① 去各大域名提供商购买我们心仪的域名，比如说阿里云、腾讯、万网等，此处不再赘述。然后进行如下配置：② 域名解析：以万网为示例，登录进入万网的域名控制台，点击”域名和网站”中的”云DNS”③ 点击对应域名的”解析”④ 点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是morningtec-moblie.github.io⑤ HEXO根目录的SOURCE文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：blog.morningtec.cn 配置Hexo主题：可能你觉得默认主题不太好看，想要设置喜欢主题。我在这把主题设置为next，最火的hexo的主题。在跟目录文件夹下输入：git clone https://github.com/iissnan/hexo-theme-next themes/next下载next主题。下面我会把E:\MyBlog\_config.yml文件称为站点配置，把E:\MyBlog\themes\next\_config.yml文件称为主题配置下载完成后，将站点配置文件的theme字段的值改为next，重新编译并上传到Github上后，访问博客链接，你就会发现主题已经改成next了，next的默认语言为英文，你可以更改为简体中文，找到并打开站点配置文件，找到language字段，将值改为zh-Hans。这里介绍下站点配置文件部分字段的含义：12345title: 晨之科SDK团队博客 // 博客名称subtitle: // 博客副名称description: // 描述author: 晨之科SDK团队 // 作者language: zh-Hans // 语言 设置NexT的菜单：编辑 主题配置文件，修改以下内容：设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 删除#就可以在博客内开启相应的菜单 NexT 默认的菜单项有: 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 到这里，你已经开启了菜单页面，并没有创建，想要创建菜单页面，在跟目录文件夹下输入hexp new page “tags”，创建tag页面，其他的页面你也可以相应的创建出来。 设置小图片：将 favicon.ico 文件放在E:\MyBlog\source目录下 设置头像：将头像图片放在E:\MyBlog\themes\next\source\images目录下，并在主题配置的avatar的字段的值改为/images/你的图片文件 设置404公益页面：在E:\MyBlog\source目录下新建 404.html 页面，404.html内容为：12345678910111213141516&lt;span style="font-size:14px;"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset="UTF-8" /&gt; &lt;title&gt;公益404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="http://blog.morningtec.cn" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;&lt;/span&gt; 设置本地站内搜索：① 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： npm install hexo-generator-searchdb --save ② 编辑站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 ③编辑主题配置文件，启用本地搜索功能：123# Local searchlocal_search: enable: true 设置评论功能：由于多说和网易云跟帖都已停止了服务，所以我在这选择了LiveRe服务① 注册LiveRe，LiveRe分为City 版（免费版本）Premium 版（收费版本）；选择免费版本就行。② 注册完成后，获取到data-uid，编辑 主题配置文件， 编辑 livere_uid 字段，设置如下：livere_uid: #your livere_uid 团队成员发布文章：① 先去github上把仓库下载下来，执行以下命令https://github.com/morningtec-moblie/MTBlog.git ② 在source/_posts/文件夹下，新建一个MarkDown格式的文章。添加文章属性（例如）： 1234567---title: 基于Hexo和Github搭建技术博客 // 博文标题date: 2017-09-28 16:30:05 // 日期tags: [hexo,github] // 标签categories: 搭建博客 // 分类comments: false // 评论功能，默认开启--- ③ 如果需要文章需要图片，在source/_posts/文件夹内新建一个和博客标题名一样的文件夹，把图片放置内，然后再MarkDown里引用（例如）： MarkDown的图片命令：![](基于Hexo和Github搭建技术博客/example.png) ④ 文章写完后，再推送到github上，然后会有人在某一时刻上传到博客。 创建文章并发布到博客：站点的根目录下执行以下命令来创建一篇文章：hexo new 基于Hexo和Github搭建技术博客通过关键字来指定文章的分类、标签及是否开启评论等功能。1234567---title: 基于Hexo和Github搭建技术博客date: 2017-09-28 16:30:05tags: [hexo,github] // 标签categories: 搭建博客 // 分类comments: false // 评论功能，默认开启--- 设置博文图片把需要的图片放置在你的博客路径\source\_posts\你的博客文件夹，之后按照正常的方法使用，例如： 1这是一张图片![](图片博文/图片.jpg) 设置阅读全文1234 文章标题 文章摘要&lt;!--more--&gt; 文章正文]]></content>
      <categories>
        <category>搭建博客</category>
        <category>by曾浩</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
